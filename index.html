<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Mobile RTA (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏û‡∏µ‡∏Ñ + Crosshair ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß) ‚Äî FFT + 1/3 Octave (Log)</title>
  <style>
    :root{ --bg1:#0b1220; --bg2:#0a1120; --card:#111827; --text:#e5e7eb; --muted:#9ca3af; }
    html,body{margin:0;height:100%;background:radial-gradient(1200px 600px at 70% -10%, #0f1730 10%, var(--bg1) 60%, var(--bg2) 100%);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Thai",sans-serif}
    .wrap{display:flex;flex-direction:column;gap:12px;max-width:920px;margin:0 auto;padding:12px}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:12px}
    button,select,input[type=range]{-webkit-tap-highlight-color:transparent}
    button{background:#10b981;border:none;color:white;padding:10px 14px;border-radius:12px;font-weight:700}
    button.secondary{background:#374151} button.ghost{background:#1f2937}
    label{font-size:12px;color:var(--muted)}
    .meters{display:grid;grid-template-columns:1fr;gap:12px}
    .stack{position:relative;height:320px}
    canvas{width:100%;height:320px;background:#0b1220;border-radius:12px;touch-action:none}
    .overlay{position:absolute;inset:0;border-radius:12px;pointer-events:none}
    .hint{font-size:12px;color:var(--muted)}
    .kv{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
    .kv div{background:#0e1628;border:1px solid #1f2937;border-radius:12px;padding:8px}
    .kv b{display:block;color:#cbd5e1;font-size:12px;margin-bottom:4px}
    .badges{display:flex;justify-content:flex-end;gap:6px;margin:4px 0 6px 0}
    .badge{padding:4px 8px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.12);font-size:12px;color:#e5e7eb}
    .tip{position:absolute;transform:translate(-50%, -8px);padding:4px 8px;border-radius:8px;background:rgba(0,0,0,.65);border:1px solid rgba(255,255,255,.15);font-size:12px;pointer-events:none;display:none}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div>
          <h2 style="margin:0 0 4px 0">Mobile RTA (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏û‡∏µ‡∏Ñ)</h2>
          <div class="hint">‡πÅ‡∏Å‡∏ô X = Log (20 Hz ‚Üí 20 kHz) ‚Ä¢ Hold Peak ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏ó‡∏±‡πâ‡∏á FFT ‡πÅ‡∏•‡∏∞ 1/3 Octave ‚Ä¢ ‡πÅ‡∏ï‡∏∞‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á Crosshair ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß</div>
        </div>
        <div class="row">
          <button id="btnStart">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ß‡∏±‡∏î</button>
          <button id="btnStop" class="secondary" disabled>‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
          <button id="btnHold" class="ghost" aria-pressed="false">üìå Hold Peak: OFF</button>
          <button id="btnClear" class="secondary">‚ôªÔ∏è Clear Peak</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <label>FFT Size
          <select id="fft">
            <option value="2048">2048</option>
            <option value="4096" selected>4096</option>
            <option value="8192">8192</option>
            <option value="16384">16384</option>
          </select>
        </label>
        <label> Smoothing <input id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.75"></label>
        <label> Averaging <input id="avg" type="checkbox" checked></label>
        <label> A-weighting (‡πÄ‡∏î‡πÇ‡∏°‡πà) <input id="aWeight" type="checkbox"></label>
      </div>
      <div class="row">
        <label>‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏õ‡∏¥‡∏î DSP ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö (‡∏ö‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏¢‡∏≠‡∏°‡∏õ‡∏¥‡∏î):</label>
        <div class="row">
          <label>echoCancellation <input id="ec" type="checkbox" checked></label>
          <label>noiseSuppression <input id="ns" type="checkbox" checked></label>
          <label>autoGainControl <input id="agc" type="checkbox" checked></label>
        </div>
      </div>
    </div>

    <div class="meters">
      <!-- FFT -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b>RTA ‡πÅ‡∏ö‡∏ö‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î (FFT, Log Frequency)</b>
          <span class="hint" id="labelRate">‚Äî</span>
        </div>
        <div class="badges">
          <span class="badge" id="fftPeakText">Peak: ‚Äî</span>
          <span class="badge" id="fftHoldText" style="display:none;">Hold: ‚Äî</span>
        </div>
        <div class="stack">
          <canvas id="fftCanvas" width="1200" height="320"></canvas>
          <canvas id="fftOverlay" class="overlay" width="1200" height="320"></canvas>
          <div id="fftTip" class="tip">‚Äî</div>
        </div>
      </div>
      <!-- 1/3 Oct -->
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:2px">
          <b>RTA ‡πÅ‡∏ö‡∏ö 1/3 Octave (Log Axis)</b>
          <span class="hint" id="labelOct">20 Hz ‚Äì 20 kHz</span>
        </div>
        <div class="badges">
          <span class="badge" id="octPeakText">Peak: ‚Äî</span>
          <span class="badge" id="octHoldText" style="display:none;">Hold: ‚Äî</span>
        </div>
        <div class="stack">
          <canvas id="octCanvas" width="1200" height="320"></canvas>
          <canvas id="octOverlay" class="overlay" width="1200" height="320"></canvas>
          <div id="octTip" class="tip">‚Äî</div>
        </div>
      </div>
    </div>

    <div class="card kv">
      <div><b>‡∏£‡∏∞‡∏î‡∏±‡∏ö RMS (‡∏î‡∏¥‡∏ö dBFS)</b><span id="rms">‚Äî</span></div>
      <div><b>‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏û‡∏µ‡∏Ñ‡πÇ‡∏î‡∏¢‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì</b><span id="peak">‚Äî</span></div>
    </div>

    <div class="card hint">‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î: ‡πÑ‡∏°‡∏Ñ‡πå‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡∏°‡∏µ DSP/AGC ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÑ‡∏°‡πà‡πÅ‡∏ü‡∏•‡∏ï ‡πÉ‡∏ä‡πâ‡∏î‡∏π‡πÅ‡∏ô‡∏ß EQ ‡πÑ‡∏î‡πâ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏°‡∏≤‡∏ï‡∏£‡∏ß‡∏±‡∏î SPL ‡∏°‡∏∑‡∏≠‡∏≠‡∏≤‡∏ä‡∏µ‡∏û</div>
  </div>

<script>
(() => {
  // Padding plot (‡πÄ‡∏û‡∏¥‡πà‡∏° B ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏Ç Hz ‡πÇ‡∏î‡∏ô‡∏ó‡∏±‡∏ö)
  const PAD = { L: 40, R: 10, T: 10, B: 32 };

  // Grid ‡∏™‡∏µ‡∏à‡∏≤‡∏á
  const GRID_H = 'rgba(255,255,255,0.06)';
  const GRID_V = 'rgba(255,255,255,0.035)';
  const FRAME  = 'rgba(255,255,255,0.08)';
  const LABEL  = 'rgba(255,255,255,0.55)';
  const LABEL_Y = 10;

  // ‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á Peak
  const PEAK_LINE  = 'rgba(96,165,250,0.6)';
  const HOLD_LINE  = 'rgba(250,204,21,0.55)';

  // Long-press ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏™‡∏î‡∏á crosshair
  const LONG_MS = 400;

  // DOM
  const btnStart = document.getElementById('btnStart');
  const btnStop  = document.getElementById('btnStop');
  const btnHold  = document.getElementById('btnHold');
  const btnClear = document.getElementById('btnClear');
  const fftSel   = document.getElementById('fft');
  const smoothing= document.getElementById('smoothing');
  const avgChk   = document.getElementById('avg');
  const aWeightChk = document.getElementById('aWeight');
  const ec = document.getElementById('ec');
  const ns = document.getElementById('ns');
  const agc = document.getElementById('agc');

  const fftPeakText = document.getElementById('fftPeakText');
  const fftHoldText = document.getElementById('fftHoldText');
  const octPeakText = document.getElementById('octPeakText');
  const octHoldText = document.getElementById('octHoldText');

  const fftCanvas = document.getElementById('fftCanvas');
  const octCanvas = document.getElementById('octCanvas');
  const fftOverlay = document.getElementById('fftOverlay');
  const octOverlay = document.getElementById('octOverlay');
  const fftTip = document.getElementById('fftTip');
  const octTip = document.getElementById('octTip');

  const ctxFFT = fftCanvas.getContext('2d');
  const ctxOct = octCanvas.getContext('2d');
  const ctxOL1 = fftOverlay.getContext('2d');
  const ctxOL2 = octOverlay.getContext('2d');

  const labelRate = document.getElementById('labelRate');
  const labelOct  = document.getElementById('labelOct');
  const rmsEl = document.getElementById('rms');
  const peakEl= document.getElementById('peak');

  // Audio
  let audioCtx, analyser, micSrc, rafId;
  let dataArray, freqArray;
  let sampleRate = 48000;
  let avgBuffer = null;
  let running = false;

  // Hold Peak
  let holdEnabled = false;
  let peakArray = null; // FFT
  let peakOct   = null; // 1/3 octave

  // 1/3 octave bands
  const centers = [20,25,31.5,40,50,63,80,100,125,160,200,250,315,400,500,630,800,1000,1250,1600,2000,2500,3150,4000,5000,6300,8000,10000,12500,16000,20000];
  const bands   = centers.map(c => ({ fc:c, fl:c/Math.pow(2,1/6), fh:c*Math.pow(2,1/6) }));
  labelOct.textContent = `${centers[0]} Hz ‚Äì ${centers[centers.length-1]} Hz`;

  // Helpers
  const dbfs = v => 20*Math.log10(v/255 + 1e-12);
  const clamp01 = v => Math.min(1, Math.max(0,v));
  function aWeighting(f){ const f2=f*f; const ra=(12200**2*f2**2)/((f2+20.6**2)*(f2+12200**2)*Math.sqrt((f2+107.7**2)*(f2+737.9**2))); return 20*Math.log10(ra)+2.0; }
  function fmtHz(f){ return f>=1000 ? ((f/1000>=10? (f/1000).toFixed(0):(f/1000).toFixed(1))+' kHz') : (Math.round(f)+' Hz'); }

  function mapLogX(f, width){
    const fmin=20, fmax=Math.min(sampleRate/2,20000);
    const t=(Math.log10(Math.max(f,fmin))-Math.log10(fmin))/(Math.log10(fmax)-Math.log10(fmin));
    return PAD.L + t * (width - PAD.L - PAD.R);
  }
  function mapDbToY(db, height){
    const norm = clamp01((db + 100) / 100);
    const plotH = height - PAD.T - PAD.B;
    return PAD.T + (1 - norm) * plotH;
  }
  function xToFreq(x, width){
    const fmin=20, fmax=Math.min(sampleRate/2,20000);
    const t = clamp01((x - PAD.L) / (width - PAD.L - PAD.R));
    const lf = Math.log10(fmin) + t * (Math.log10(fmax) - Math.log10(fmin));
    return Math.pow(10, lf);
  }

  // Grid + labels
  function drawBackground(ctx){
    const {width:w, height:h} = ctx.canvas;
    ctx.clearRect(0,0,w,h);
    const plotH = h - PAD.T - PAD.B;

    ctx.strokeStyle = GRID_H;
    for(let i=0;i<6;i++){
      const y = PAD.T + (i/5) * plotH;
      ctx.beginPath(); ctx.moveTo(PAD.L,y); ctx.lineTo(w-PAD.R,y); ctx.stroke();
    }

    ctx.strokeStyle = GRID_V;
    const ticks=[20,31.5,40,50,63,80,100,125,160,200,250,315,400,500,630,800,1000,2000,4000,8000,16000];
    ticks.forEach(t=>{
      const x=mapLogX(t,w); ctx.beginPath(); ctx.moveTo(x,PAD.T); ctx.lineTo(x, PAD.T+plotH); ctx.stroke();
    });

    ctx.strokeStyle = FRAME;
    ctx.strokeRect(PAD.L, PAD.T, w-PAD.L-PAD.R, plotH);

    ctx.fillStyle = LABEL;
    ctx.font = '12px system-ui';
    ctx.textBaseline = 'alphabetic';
    [31.5,63,125,250,500,1000,2000,4000,8000,16000].forEach(t=>{
      const x=mapLogX(t,w);
      ctx.fillText(t>=1000?(t/1000)+'k':t, x-8, h - LABEL_Y);
    });
  }

  // ‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏û‡∏µ‡∏Ñ
  function drawPeakLine(ctx, x, h, color, dashed=false){
    const y0 = PAD.T, y1 = h - PAD.B;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    if(dashed) ctx.setLineDash([5,5]);
    ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y1); ctx.stroke();
    ctx.restore();
  }

  // ========= FFT =========
  function drawFFT(){
    const {width:w,height:h} = ctxFFT.canvas;
    drawBackground(ctxFFT);
    if(!freqArray) return;

    const N=freqArray.length; const fpb=sampleRate/(2*N);

    // peak (current)
    let peakBin=0, peakVal=-Infinity;
    for(let i=0;i<N;i++){ if(freqArray[i]>peakVal){ peakVal=freqArray[i]; peakBin=i; } }
    const peakFreqNow = peakBin*fpb;
    const peakDbNow = dbfs(freqArray[peakBin]);
    peakEl.textContent = Math.round(peakFreqNow) + ' Hz';

    if(!peakArray || peakArray.length!==N) peakArray=new Uint8Array(N);
    if(holdEnabled) for(let i=0;i<N;i++) peakArray[i] = Math.max(peakArray[i], freqArray[i]);

    // current (‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß)
    ctxFFT.beginPath(); let started=false;
    for(let i=1;i<N;i++){
      const f=i*fpb; if(f<20) continue; if(f>20000) break;
      const x=mapLogX(f,w);
      const y=mapDbToY(dbfs(freqArray[i]), h);
      if(!started){ ctxFFT.moveTo(x,y); started=true; } else ctxFFT.lineTo(x,y);
    }
    ctxFFT.strokeStyle='#34d399'; ctxFFT.lineWidth=2; ctxFFT.stroke();

    // peak-hold (‡∏°‡πà‡∏ß‡∏á ‡∏à‡∏≤‡∏á)
    ctxFFT.beginPath(); started=false;
    for(let i=1;i<N;i++){
      const f=i*fpb; if(f<20) continue; if(f>20000) break;
      const x=mapLogX(f,w);
      const y=mapDbToY(dbfs(peakArray[i]||0), h);
      if(!started){ ctxFFT.moveTo(x,y); started=true; } else ctxFFT.lineTo(x,y);
    }
    ctxFFT.save(); ctxFFT.globalAlpha=0.35; ctxFFT.strokeStyle='#a78bfa'; ctxFFT.lineWidth=1.25; ctxFFT.stroke(); ctxFFT.restore();

    // ‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏û‡∏µ‡∏Ñ
    const xPeakNow = mapLogX(peakFreqNow, w);
    drawPeakLine(ctxFFT, xPeakNow, h, PEAK_LINE, false);

    // ‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á hold
    let holdBin=0, holdVal=0;
    for(let i=0;i<N;i++){ if(peakArray[i]>holdVal){ holdVal=peakArray[i]; holdBin=i; } }
    if(holdVal>0){
      const xHold = mapLogX(holdBin*fpb, w);
      drawPeakLine(ctxFFT, xHold, h, HOLD_LINE, true);
    }

    // ‡∏õ‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏≤‡∏ô‡∏ô‡∏≠‡∏Å‡∏Å‡∏£‡∏≤‡∏ü
    fftPeakText.textContent = `Peak: ${fmtHz(peakFreqNow)} ‚Ä¢ ${peakDbNow.toFixed(1)} dBFS`;
    if(holdVal>0){
      fftHoldText.style.display='';
      fftHoldText.textContent = `Hold: ${fmtHz(holdBin*fpb)} ‚Ä¢ ${dbfs(holdVal).toFixed(1)} dBFS`;
    }else{
      fftHoldText.style.display='none';
    }
  }

  // ========= OCT =========
  function drawOctave(){
    const {width:w,height:h} = ctxOct.canvas;
    drawBackground(ctxOct);
    if(!freqArray) return;

    const N=freqArray.length; const fpb=sampleRate/(2*N);

    const vals = bands.map(b=>{
      const s=Math.max(0,Math.floor(b.fl/fpb)), e=Math.min(N-1,Math.ceil(b.fh/fpb));
      let sum=0,cnt=0; for(let i=s;i<=e;i++){ sum+=freqArray[i]; cnt++; }
      let v=cnt?(sum/cnt):0;
      if(aWeightChk.checked) v*=Math.pow(10, aWeighting(b.fc)/20);
      return v;
    });

    if(!peakOct || peakOct.length!==vals.length) peakOct=new Float32Array(vals.length);
    if(holdEnabled) for(let i=0;i<vals.length;i++) peakOct[i]=Math.max(peakOct[i], vals[i]);

    // ‡πÅ‡∏ó‡πà‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß)
    ctxOct.fillStyle='#34d399';
    for(let i=0;i<vals.length;i++){
      const b=bands[i];
      const xL=mapLogX(b.fl,w), xR=mapLogX(b.fh,w);
      const barW=Math.max(2, xR-xL-2);
      const y=mapDbToY(dbfs(vals[i]), h);
      const plotBottom=h-PAD.B;
      const hh=(plotBottom - y);
      ctxOct.fillRect(xL+1, y, barW, Math.max(1, hh));
    }

    // ‡πÄ‡∏™‡πâ‡∏ô‡∏û‡∏µ‡∏Ñ (‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á ‡∏à‡∏≤‡∏á)
    ctxOct.beginPath();
    for(let i=0;i<vals.length;i++){
      const cx=mapLogX(bands[i].fc,w);
      const y=mapDbToY(dbfs(peakOct[i]||0), h);
      if(i===0) ctxOct.moveTo(cx,y); else ctxOct.lineTo(cx,y);
    }
    ctxOct.save(); ctxOct.globalAlpha=0.45; ctxOct.strokeStyle='#facc15'; ctxOct.lineWidth=1.5; ctxOct.stroke(); ctxOct.restore();
    ctxOct.fillStyle='rgba(250,204,21,0.35)';
    for(let i=0;i<vals.length;i++){
      const cx=mapLogX(bands[i].fc,w);
      const y=mapDbToY(dbfs(peakOct[i]||0), h);
      ctxOct.fillRect(cx-1.5, y-1.5, 3, 3);
    }

    // ‡∏û‡∏µ‡∏Ñ‡∏Ç‡∏≠‡∏á‡∏¢‡πà‡∏≤‡∏ô
    let idxNow=0, vNow=-1;
    for(let i=0;i<vals.length;i++){ if(vals[i]>vNow){ vNow=vals[i]; idxNow=i; } }
    const xPeakNow = mapLogX(bands[idxNow].fc, w);
    drawPeakLine(ctxOct, xPeakNow, h, PEAK_LINE, false);

    // hold line
    let idxHold=0, vHold=0;
    for(let i=0;i<peakOct.length;i++){ if(peakOct[i]>vHold){ vHold=peakOct[i]; idxHold=i; } }
    if(vHold>0){
      const xHold = mapLogX(bands[idxHold].fc, w);
      drawPeakLine(ctxOct, xHold, h, HOLD_LINE, true);
    }

    // ‡∏õ‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏≤‡∏ô‡∏ô‡∏≠‡∏Å‡∏Å‡∏£‡∏≤‡∏ü
    octPeakText.textContent = `Peak: ${fmtHz(bands[idxNow].fc)} ‚Ä¢ ${dbfs(vNow).toFixed(1)} dBFS`;
    if(vHold>0){
      octHoldText.style.display='';
      octHoldText.textContent = `Hold: ${fmtHz(bands[idxHold].fc)} ‚Ä¢ ${dbfs(vHold).toFixed(1)} dBFS`;
    }else{
      octHoldText.style.display='none';
    }
  }

  // ========= Crosshair ‡∏ä‡∏±‡πà‡∏ß‡∏Ñ‡∏£‡∏≤‡∏ß (‡πÅ‡∏ï‡∏∞‡∏Ñ‡πâ‡∏≤‡∏á) =========
  function setupCrosshair(baseCanvas, overlayCtx, tipEl){
    let pressTimer=null, active=false;

    function clearOverlay(){
      overlayCtx.clearRect(0,0, overlayCtx.canvas.width, overlayCtx.canvas.height);
      tipEl.style.display='none';
    }

    function drawCrosshair(clientX, clientY){
      const rect = baseCanvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const w = overlayCtx.canvas.width;
      const h = overlayCtx.canvas.height;

      // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà plot
      const xPlot = Math.min(w-PAD.R, Math.max(PAD.L, x));
      const yPlot = Math.min(h-PAD.B, Math.max(PAD.T, y));

      const f = xToFreq(xPlot, w);

      overlayCtx.clearRect(0,0,w,h);
      overlayCtx.save();
      // clip ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏Å‡∏£‡∏≠‡∏ö
      overlayCtx.beginPath();
      overlayCtx.rect(PAD.L, PAD.T, w-PAD.L-PAD.R, h-PAD.T-PAD.B);
      overlayCtx.clip();

      overlayCtx.strokeStyle='rgba(255,255,255,0.35)';
      overlayCtx.lineWidth=1;
      overlayCtx.setLineDash([4,4]);

      // ‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á/‡∏ô‡∏≠‡∏ô
      overlayCtx.beginPath();
      overlayCtx.moveTo(xPlot, PAD.T); overlayCtx.lineTo(xPlot, h-PAD.B);
      overlayCtx.moveTo(PAD.L, yPlot); overlayCtx.lineTo(w-PAD.R, yPlot);
      overlayCtx.stroke();
      overlayCtx.restore();

      // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á tooltip (‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≠‡∏Å overlay, ‡πÉ‡∏ä‡πâ absolutely on .stack)
      tipEl.textContent = fmtHz(f);
      tipEl.style.left = `${xPlot}px`;
      tipEl.style.top  = `${(yPlot>PAD.T+20? yPlot: (PAD.T+20))}px`;
      tipEl.style.display='block';
    }

    baseCanvas.addEventListener('pointerdown', (ev)=>{
      if(pressTimer) clearTimeout(pressTimer);
      pressTimer = setTimeout(()=>{ active=true; drawCrosshair(ev.clientX, ev.clientY); }, LONG_MS);
    }, {passive:true});

    baseCanvas.addEventListener('pointermove', (ev)=>{
      if(active) drawCrosshair(ev.clientX, ev.clientY);
    }, {passive:true});

    ['pointerup','pointercancel','pointerleave'].forEach(evName=>{
      baseCanvas.addEventListener(evName, ()=>{
        if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; }
        if(active){ active=false; clearOverlay(); }
      }, {passive:true});
    });
  }
  setupCrosshair(fftCanvas, ctxOL1, fftTip);
  setupCrosshair(octCanvas, ctxOL2, octTip);

  // ========= RMS + Loop =========
  function updateRMS(){
    if(!dataArray) return;
    let sum=0; for(let i=0;i<dataArray.length;i++){ const v=(dataArray[i]-128)/128; sum+=v*v; }
    const rms=Math.sqrt(sum/dataArray.length);
    const db=20*Math.log10(rms+1e-12);
    rmsEl.textContent = db.toFixed(1)+' dBFS';
  }

  function loop(){
    if(!running) return;
    analyser.getByteTimeDomainData(dataArray);
    analyser.getByteFrequencyData(freqArray);

    if(avgChk.checked){
      if(!avgBuffer || avgBuffer.length!==freqArray.length) avgBuffer=new Float32Array(freqArray.length);
      const alpha=0.5;
      for(let i=0;i<freqArray.length;i++){
        avgBuffer[i]=alpha*avgBuffer[i]+(1-alpha)*freqArray[i];
        freqArray[i]=avgBuffer[i];
      }
    }

    drawFFT(); drawOctave(); updateRMS();
    rafId=requestAnimationFrame(loop);
  }

  // ========= Start/Stop =========
  async function start(){
    try{
      btnStart.disabled=true; btnStop.disabled=false;
      const constraints={ audio:{ echoCancellation: ec.checked? false:true, noiseSuppression: ns.checked? false:true, autoGainControl: agc.checked? false:true } };
      const stream=await navigator.mediaDevices.getUserMedia(constraints);
      audioCtx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
      if(audioCtx.state==='suspended') await audioCtx.resume();

      sampleRate=audioCtx.sampleRate;
      labelRate.textContent = `${Math.round(sampleRate)} Hz`;

      analyser=audioCtx.createAnalyser();
      analyser.fftSize=parseInt(fftSel.value,10);
      analyser.smoothingTimeConstant=parseFloat(smoothing.value);

      micSrc=audioCtx.createMediaStreamSource(stream);
      micSrc.connect(analyser);

      dataArray=new Uint8Array(analyser.fftSize);
      freqArray=new Uint8Array(analyser.frequencyBinCount);
      peakArray=new Uint8Array(analyser.frequencyBinCount);
      peakOct  =new Float32Array(centers.length);

      running=true; loop();
    }catch(err){
      alert('‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏°‡πÇ‡∏Ñ‡∏£‡πÇ‡∏ü‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: '+(err.message||err));
      btnStart.disabled=false; btnStop.disabled=true;
    }
  }
  function stop(){
    running=false; if(rafId) cancelAnimationFrame(rafId);
    try{micSrc&&micSrc.disconnect();}catch{} try{analyser&&analyser.disconnect();}catch{}
    if(audioCtx){audioCtx.close();}
    btnStart.disabled=false; btnStop.disabled=true;
  }

  // ========= Events =========
  btnStart.addEventListener('click', start, {passive:true});
  btnStop .addEventListener('click', stop , {passive:true});
  btnHold .addEventListener('click', ()=>{
    holdEnabled=!holdEnabled;
    btnHold.setAttribute('aria-pressed', String(holdEnabled));
    btnHold.textContent = holdEnabled ? 'üìå Hold Peak: ON' : 'üìå Hold Peak: OFF';
  }, {passive:true});
  btnClear.addEventListener('click', ()=>{
    if(peakArray) peakArray.fill(0);
    if(peakOct)   peakOct.fill(0);
  }, {passive:true});
  fftSel.addEventListener('change', ()=>{
    if(!analyser) return;
    analyser.fftSize=parseInt(fftSel.value,10);
    dataArray=new Uint8Array(analyser.fftSize);
    freqArray=new Uint8Array(analyser.frequencyBinCount);
    peakArray=new Uint8Array(analyser.frequencyBinCount);
    peakOct  =new Float32Array(centers.length);
  });
  smoothing.addEventListener('input', ()=>{ if(analyser) analyser.smoothingTimeConstant=parseFloat(smoothing.value); });

  // ‡∏Å‡∏±‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ï‡∏≠‡∏ô‡∏•‡∏≤‡∏Å‡∏™‡πÑ‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ö‡∏ô iOS
  document.querySelectorAll('input[type=range]').forEach(el=>{
    el.addEventListener('touchmove', e=>e.stopPropagation(), {passive:true});
  });
})();
</script>
</body>
</html>
